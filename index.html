<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Product Data Extractor</title>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 28px; color: #111; }
    h1 { text-align: left; margin-bottom: 14px; }
    label { display:block; margin-top:12px; margin-bottom:6px; font-weight:600; }
    textarea { width:100%; height:180px; padding:10px; border:1px solid #ccc; border-radius:6px; font-family: monospace; font-size:13px; }
    select, button { padding:10px 14px; margin-top:6px; border-radius:6px; border:1px solid #bbb; }
    button { background:#f5f5f5; cursor:pointer; }
    #controls { margin-top:18px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    #status { color:#444; margin-top:8px; }
    #downloadBtn { display:none; background:#2b8bd3; color:white; padding:8px 12px; text-decoration:none; border-radius:6px; }
    table { width:100%; border-collapse:collapse; margin-top:16px; }
    th, td { border:1px solid #e6e6e6; padding:8px; text-align:left; font-size:13px; }
    thead th { background:#fafafa; }
    #results { margin-top:18px; }
    .small { font-size:13px; color:#666; }
  </style>
</head>
<body>
  <h1>Product Data Extractor</h1>

  <label for="site">Select Website:</label>
  <select id="site">
    <option value="macys">Macy's</option>
  </select>

  <label for="urls">Paste URLs (one per line):</label>
  <textarea id="urls" placeholder="https://www.macys.com/...?ID=..."></textarea>

  <div id="controls">
    <button id="submitBtn" type="button">Submit to Queue</button>
    <a id="downloadBtn" download>Download CSV</a>
    <div id="status" class="small">Not connected to backend yet.</div>
  </div>

  <div id="results"></div>

  <script>
  // -------------- CONFIG --------------
  const BACKEND = 'https://synonymous-julie-trilaterally.ngrok-free.dev'; // your ngrok URL
  // ------------------------------------

  // DOM refs
  const statusEl = document.getElementById('status');
  const downloadBtn = document.getElementById('downloadBtn');
  const tableContainer = document.getElementById('results');
  const submitBtn = document.getElementById('submitBtn');
  const urlsInput = document.getElementById('urls');

  // Hide download initially
  downloadBtn.style.display = 'none';

  // Socket variable
  let socket = null;

  function connectSocket() {
    try {
      socket = io(BACKEND, {
        transports: ['websocket', 'polling'],
        secure: true,
        timeout: 10000
      });
    } catch (e) {
      console.error('Socket init error', e);
      statusEl.innerText = 'Socket init error — check BACKEND value and ngrok.';
      return;
    }

    socket.on('connect', () => {
      console.log('Socket connected', socket.id);
      statusEl.innerText = 'Socket connected. Ready to submit.';
    });

    socket.on('connect_error', (err) => {
      console.error('Socket connect_error', err);
      statusEl.innerText = 'Socket connection failed — make sure ngrok & backend are running.';
      alert('Socket connection failed. Make sure your ngrok tunnel and local server are running.');
    });

    socket.on('queue_update', (payload) => {
      // payload: { position, total, message }
      if (!payload) return;
      statusEl.innerText = payload.message || `Position ${payload.position || '?'} / ${payload.total || '?'}`;
    });

    socket.on('extraction_complete', async (data) => {
      try {
        const rel = (data && data.downloadUrl) ? data.downloadUrl : null;
        const fullUrl = rel ? (rel.startsWith('http') ? rel : (BACKEND + rel)) : null;
        if (fullUrl) {
          downloadBtn.href = fullUrl;
          downloadBtn.style.display = 'inline-block';
        }
        statusEl.innerText = '✅ Extraction complete! Preparing preview...';

        if (fullUrl) {
          try {
            const res = await fetch(fullUrl);
            if (!res.ok) throw new Error('Failed to fetch CSV: ' + res.status);
            const txt = await res.text();
            renderCsvPreview(txt);
            statusEl.innerText = '✅ Extraction complete — preview below. Use Download CSV to save.';
          } catch (err) {
            console.error('CSV preview fetch failed', err);
            statusEl.innerText = 'Extraction complete. Click Download CSV to save the file.';
          }
        }
      } catch (err) {
        console.error('extraction_complete handler error', err);
      }
    });

    socket.on('error', (e) => {
      console.error('Socket error', e);
    });
  }

  function renderCsvPreview(csvText) {
    if (!csvText) {
      tableContainer.innerHTML = '<p class="small">No CSV content</p>';
      return;
    }
    // naive CSV parse that handles simple quoted fields
    const rows = csvText.trim().split(/\r?\n/).map(line => {
      const cells = [];
      let cur = '', inQuotes = false;
      for (let i=0;i<line.length;i++){
        const ch = line[i];
        if (ch === '"' ) {
          if (inQuotes && line[i+1] === '"') { cur += '"'; i++; continue; }
          inQuotes = !inQuotes;
          continue;
        }
        if (ch === ',' && !inQuotes) { cells.push(cur); cur=''; continue; }
        cur += ch;
      }
      cells.push(cur);
      return cells;
    });

    if (rows.length === 0) {
      tableContainer.innerHTML = '<p class="small">CSV empty</p>';
      return;
    }

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    rows[0].forEach(h => {
      const th = document.createElement('th');
      th.innerText = (h||'').replace(/^"|"$/g,'');
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (let r=1; r<Math.min(rows.length, 501); r++) {
      const tr = document.createElement('tr');
      rows[r].forEach(c => {
        const td = document.createElement('td');
        td.innerText = (c||'').replace(/^"|"$/g,'');
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);

    tableContainer.innerHTML = '';
    tableContainer.appendChild(table);
  }

  async function submitToQueue() {
    if (!socket || socket.disconnected) {
      alert('Socket not connected. Make sure ngrok and the backend are running.');
      return;
    }
    const raw = urlsInput.value.trim();
    if (!raw) {
      alert('Please paste one or more URLs (one per line).');
      return;
    }
    const urls = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    statusEl.innerText = 'Submitting...';

    try {
      const res = await fetch(BACKEND + '/queue_submit', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ urls })
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error('Server returned ' + res.status + ': ' + text);
      }
      const json = await res.json();
      const userId = json.userId || json.id || json.room;
      if (userId) {
        if (socket.connected) socket.emit('join_queue', userId);
        else socket.once('connect', () => socket.emit('join_queue', userId));
      }
      statusEl.innerText = json.message || 'Submitted — waiting in queue.';
      if (json.position) statusEl.innerText = `Position ${json.position}/${json.total || '?'}`;
    } catch (err) {
      console.error('Submit error', err);
      alert('Error submitting: ' + err.message);
      statusEl.innerText = 'Error submitting. See console.';
    }
  }

  // Initialize
  connectSocket();
  submitBtn.addEventListener('click', (e) => { e.preventDefault(); submitToQueue(); });

  </script>
</body>
</html>
